# 1. Why you need an API Gateway?

## API Gateway & The Facade Pattern

### 1. The "Why": The Problem with Direct Access

The Scenario:

Imagine a large hotel.

* Current State (Monolith/Direct Access): Guests (Clients) don't go to the reception. Instead, they wander the halls looking for the kitchen, the laundry room, and the housekeeping staff directly. They knock on every door.
* The Risk:
  * Security: Strangers are wandering the hallways (Public IPs exposed).
  * Complexity: If the kitchen moves to the 2nd floor, every guest needs to be told the new room number (Hardcoded IPs/URLs).
  * Chaos: If 1,000 guests ask the chef for a sandwich at once, the kitchen crashes (No Rate Limiting).

Technical Translation:

Right now, your clients (Mobile App/Web) are talking directly to your microservices.

* You are exposing public ports (e.g., `:8080`, `:3000`) to the internet.
* Your custom routing app handles _where_ to go, but it likely doesn't handle _protection_ or _standardization_.

***

### 2. Core Concept: The API Gateway

Definition: An API Gateway is a server that sits between the client (Mobile/Web) and the backend microservices. It acts as a Single Entry Point.

The "Facade" Design Pattern:

In software engineering, a Facade hides a complex system behind a simple interface.

* Client sees: `api.myfinanceapp.com/pay`
* Reality: The Gateway receives the request, translates it, and routes it to `10.0.0.5:8080` (The Payment Service).
* Benefit: The client _never_ knows the IP address or the complexity of the backend. You can change the backend completely, and the client won't know.

***

### 3. Forward Proxy vs. Reverse Proxy

Analogy:

* Forward Proxy (VPN): Protects the Client.
  * _Scenario:_ An employee inside a corporate network wants to visit Google. The request goes through a proxy so Google sees the _Company's IP_, not the _Employee's IP_.
* Reverse Proxy (Gateway): Protects the Server.
  * _Scenario:_ A user on the internet wants to visit your bank. They hit the Gateway. The Gateway talks to the internal server. The User never touches the internal server directly.

Why you need a Reverse Proxy (API Gateway):

1. SSL Termination: Decrypting HTTPS is "expensive" (CPU heavy). Do you want your "Loan Service" wasting CPU on encryption, or calculating interest? Let the Gateway handle the heavy lifting of SSL.
2. IP Masking: With a Gateway, your microservices live on a Private Network. They have NO public IP addresses. They are invisible to the internet. This eliminates 90% of attack vectors.

### 4. The "Cross-Cutting Concerns" (Offloading)

In a Microservices architecture, you have 50 services. Do you want to implement the following logic in all 50 of them?

1. Authentication: "Is this user logged in?"
2. Rate Limiting: "Allow only 100 requests per minute."
3. Logging: "Record that a request came in."
4. CORS: "Allow browser requests."

The Gateway Solution:

You implement these once at the Gateway level.

* The Gateway checks the Token. If invalid, it rejects the request (401 Unauthorized). The Microservice is never even bothered.
* The Gateway enforces the limit.
* The Microservice focuses purely on Business Logic (e.g., "Calculate Loan Eligibility").

### 5. Specific Solution for Your Migration

_Directly addressing their specific toolset._

Current State:

* Custom Node app doing routing.
* Risks: High maintenance. Who patches security holes in that custom app? Does it handle efficient load balancing?

Recommended State:

* Tools: NGINX (Lightweight, fast), Kong (Built on NGINX, adds plugins for Auth/Rate Limiting), or AWS API Gateway (Managed).
* Transition Plan:
  1. Deploy Kong/NGINX in front of the existing custom router.
  2. Move Authentication logic from the services to the Gateway.
  3. Close the public ports on the microservices. Only allow traffic from the Gateway's IP.

### 6. Diagramming Exercise (Whiteboard this!)

The "Happy Path" Request Flow:

1. Client (Mobile App) sends `POST /transfer` to `api.bank.com` (The Gateway).
2. Gateway acts as the Bouncer:
   * _Check 1:_ Is the SSL cert valid? (Yes) -> Decrypt.
   * _Check 2:_ Does the user have a valid Token? (Yes).
   * _Check 3:_ Is the user spamming us? (No).
3. Gateway looks up the route: "Ah, `/transfer` belongs to the Transaction Service."
4. Gateway calls `192.168.1.50:8080` (Private IP of the Service).
5. Service processes the logic and returns `200 OK`.
6. Gateway returns the response to the Client.

# 5. Distributed Transactions â€“ The "Lost Money" Risk

#### 1. The "Oh No" Moment: The Loss of ACID

In your monolith, you had a safety net called ACID (Atomicity, Consistency, Isolation, Durability).

*   The Monolith Way: When a user sends money, you wrap the SQL in a transaction:

    SQL

    ```
    BEGIN TRANSACTION;
      UPDATE accounts SET balance = balance - 100 WHERE id = 'UserA';
      UPDATE accounts SET balance = balance + 100 WHERE id = 'UserB';
      INSERT INTO transaction_log ...;
    COMMIT; -- If anything fails before here, EVERYTHING rolls back automatically.
    ```

The Microservice Reality:

Now, "Accounts" and "Transaction Logs" live in different databases on different servers.

* You call Service A (Withdraw Money). Success.
* You call Service B (Deposit Money). Network Fails.
* Result: Money has left User A but never arrived at User B. The money has vanished. You cannot issue a `ROLLBACK` command to Service A because it already committed its transaction.

#### 2. The Mental Shift: From ACID to BASE

To survive in a distributed world, we must move from strict consistency to Eventual Consistency.

* ACID: The system is consistent at _every single moment_. (Hard to scale).
* BASE:
  * Basically Available: The system guarantees availability.
  * Soft State: The state of the system may change over time, even without input (due to eventual consistency updates).
  * Eventual Consistency: The system will _eventually_ become consistent once it stops receiving input.

_In Finance terms:_ It is okay if the "View Balance" screen is out of date by 200ms, as long as the Ledger eventually reconciles correctly.

#### 3. The Solution: The Saga Pattern

Since we can't have one big transaction, we break it into a sequence of Local Transactions. This chain is called a Saga.

How it works:

1. Step 1: Service A runs a local transaction (deduct money) & commits.
2. Step 2: Service A triggers Service B.
3. Step 3: Service B runs a local transaction (add money) & commits.

"But what if Step 3 fails?"

You cannot "rollback" Step 1. You must run a Compensating Transaction.

* A Compensating Transaction is a new transaction that undoes the effect of a previous one.
* _Example:_ If "Deduct Money" was the action, "Refund Money" is the compensation.

#### 4. Implementing Sagas: Two Flavors

There are two ways to coordinate this dance.

**A. Choreography (The Dance)**

There is no central manager. Services listen to events and react.

* The Flow:
  1. Order Service: Creates an Order (Pending) -> Publishes Event `OrderCreated`.
  2. Payment Service: Listens to `OrderCreated` -> Processes Payment -> Publishes `PaymentProcessed`.
  3. Inventory Service: Listens to `PaymentProcessed` -> Reserves Stock -> Publishes `StockReserved`.
  4. Order Service: Listens to `StockReserved` -> Updates Order to "Confirmed".
* Handling Failure:
  * If Inventory fails (Out of Stock), it publishes `StockFailed`.
  * Payment Service listens to `StockFailed` -> Refunds the user (Compensation).
  * Order Service listens to `StockFailed` -> Cancels the order.
* Pros: Simple to start, loose coupling.
* Cons: Hard to track. "Who listens to what?" becomes a confusing web.

**B. Orchestration (The Conductor)**

A central service (The Orchestrator) tells everyone what to do.

* The Flow:
  1. Order Service (Orchestrator): Tells Payment Service: "Charge the user."
  2. Payment Service: Replies "Done."
  3. Order Service: Tells Inventory Service: "Reserve stock."
  4. Inventory Service: Replies "Out of Stock!" (Error).
  5. Order Service: Realizes the error and tells Payment Service: "Please Issue Refund" (Compensation).
* Pros: Clear flow logic. You can look at the code in one place and see the whole process. Great for complex financial flows.
* Cons: The Orchestrator can become a "God Service" if too much logic is put there.

#### 5. Summary Comparison

| **Feature**   | **Choreography (Events)**               | **Orchestration (Command)**                  |
| ------------- | --------------------------------------- | -------------------------------------------- |
| Coordinator   | None (Decentralized)                    | Central Service                              |
| Communication | Async Events ("I did X")                | Sync/Async Commands ("Do X")                 |
| Complexity    | Low initially, High as system grows     | Moderate initially, stays manageable         |
| Coupling      | Very Low                                | Higher (Orchestrator knows about others)     |
| Best For...   | Simple flows (e.g., Email notification) | Complex Business Logic (e.g., Loan Approval) |

#### 6. Quiz: Check Your Understanding

1. Scenario: In a banking transfer, the "Credit" service is down. The "Debit" service already took the money. In a Saga Orchestration pattern, what happens next?
   * _Answer: The Orchestrator detects the failure from the Credit service and sends a "Compensate" command to the Debit service to refund the money._
2. Scenario: Why don't we just use "Two-Phase Commit" (2PC/XA Transactions)?
   * _Answer: 2PC requires locking resources across databases while waiting for everyone to agree. In a distributed system, this kills performance and availability. If one service hangs, the whole system hangs._

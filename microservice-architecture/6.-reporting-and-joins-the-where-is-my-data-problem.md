# 6. Reporting & Joins â€“ The "Where is my Data?" Problem

#### 1. The Problem: The Death of the SQL JOIN

In the monolithic days, generating a "Monthly Transaction Report" for a user was trivial.

* The SQL: `SELECT * FROM Transactions t JOIN Users u ON t.user_id = u.id WHERE u.region = 'US'`.
* The Result: The database engine optimized this query and returned the data in milliseconds.

The Microservice Reality:

Now, Users lives in the Identity Service (Oracle DB) and Transactions lives in the Ledger Service (Postgres DB).

* You cannot run a JOIN query across two physical servers.
* If you try to simulate this in code, you hit the N+1 Problem:
  1. Call Ledger Service to get 100 recent transactions (1 Call).
  2. Loop through _each_ transaction to fetch the user's name from the Identity Service (100 Calls).
  3. Total: 101 Network calls for one screen. This is painfully slow.

#### 2. Strategy A: API Composition (The "Stitcher")

For simple screens (like a "User Profile" page that shows the user's name and their last 5 orders), this is the easiest solution.

How it works:

You create a specialized service (often called an Aggregator or BFF - Backend for Frontend) that sits between the client and the microservices.

1. Request: Client asks Aggregator: "Get Profile Data."
2. Parallel Calls: The Aggregator calls the "User Service" and "Order Service" simultaneously.
3. Stitching: The Aggregator waits for both results, combines them into one JSON object, and sends it back.

When to use it:

* Simple reads (Single object lookups).
* Real-time data is required.

The Limitation:

This falls apart for Complex Reports. Imagine filtering: "Show me all Orders where the User lives in 'New York' and the Item Price is > $50."

* To do this via API Composition, you'd have to fetch _all_ users in New York, then ask the Order service for _all_ their orders, and then filter by price. It is inefficient and memory-heavy.

***

#### 3. Strategy B: CQRS (Command Query Responsibility Segregation)

This is the "nuclear option" for handling complex data needs. It acknowledges that Writing data and Reading data have different requirements.

* Command (Write): Needs normalized data, validation, and consistency. (e.g., "Create Invoice").
* Query (Read): Needs denormalized, flat data, and speed. (e.g., "Search Invoices").

The Solution: Split them.

Instead of reading from the microservices' operational databases, we create a separate Read Database (or View Database) specifically designed for querying.

How it works (The Flow):

1. Write Side: The "User Service" updates a user's address. It writes to its private DB.
2. Publish: The User Service publishes an event: `UserAddressUpdated`.
3. Read Side: A separate process (Projector) listens to this event.
4. Update View: It updates a specific Read Database (e.g., ElasticSearch or a flat SQL table) that contains a pre-joined view of "Users + Orders".

The Result:

When the boss asks for "All Orders in New York > $50", you query the Read Database.

* The data is already joined and flattened.
* The query is instant: `SELECT * FROM DashboardView WHERE City='NY' AND Price > 50`.
*

    <figure><img src="https://encrypted-tbn0.gstatic.com/licensed-image?q=tbn:ANd9GcTN9zIAqyhO9MXzg2F0zb4AZ4EAcRN9ofEZlDpsfjIJHM7LRWaQKJXGoW25xlVPUh5IREZFiZnPiYmKFDMLOXanJ1BKROgZ-veoNGoNPStrqx7EqqI" alt=""><figcaption></figcaption></figure>

#### 4. Comparison: Composition vs. CQRS

| **Feature**    | **API Composition (Stitching)**         | **CQRS (Separate Read DB)**                 |
| -------------- | --------------------------------------- | ------------------------------------------- |
| Complexity     | Low                                     | High (requires syncing mechanisms)          |
| Data Freshness | Real-time (Always current)              | Eventual Consistency (Lag of ms to seconds) |
| Performance    | Slower (Limited by network calls)       | Extremely Fast (Pre-calculated views)       |
| Best For...    | User Profile, Details Page              | Search, Dashboards, Complex Filtering       |
| Analogy        | Cooking a meal from scratch every time. | Reheating a pre-cooked meal.                |

***

#### 5. Quiz: Check Your Understanding

1. Scenario: The marketing team wants a search engine where they can type "John" and see his loans, credit cards, and savings accounts instantly. Which pattern is best?
   * _Answer: CQRS. Searching across three domains in real-time via API Composition would be slow. Better to index all that data into a single search engine (like ElasticSearch) that listens to updates from all three services._
2. Scenario: A user updates their profile picture. They refresh the page, but the old picture is still there for 2 seconds. Why?
   * _Answer: This is "Eventual Consistency" in CQRS. The event `ProfilePictureUpdated` took a few seconds to propagate to the Read Database._

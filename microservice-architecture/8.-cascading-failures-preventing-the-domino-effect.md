# 8. Cascading Failures â€“ Preventing the Domino Effect

#### 1. The Nightmare Scenario: The Domino Effect

In a distributed system, your application is only as available as its least reliable dependency - unless you code defensively.

The Scenario:

1. User calls the Storefront Service.
2. Storefront calls the Inventory Service to check stock.
3. Inventory Service is having a bad day (maybe a slow database query). It takes 30 seconds to respond.
4. Result: The Storefront Service waits. And waits.
5. The Crash: While Storefront is waiting, it holds onto a "Thread" (a unit of processing power).
   * If 1,000 users click "Buy," 1,000 threads in the _Storefront_ get stuck waiting for _Inventory_.
   * The Storefront runs out of threads. It stops responding to _everyone_, even people just trying to view the home page.
   * One slow service just killed a totally different service. This is a Cascading Failure.

#### 2. Defense Line 1: Timeouts (Stop Waiting)

The simplest defense is to never wait forever.

* The Rule: Every network call _must_ have a timeout.
* The Implementation: If the Inventory Service doesn't answer in 2 seconds, cut the connection and return an error (or a fallback message).
* Why it helps: It frees up the thread in the Storefront Service so it can handle other requests.

_Warning:_ Setting timeouts too short causes false failures. Setting them too long risks resource exhaustion. It requires tuning.

#### 3. Defense Line 2: Retries (Try Again... Carefully)

If a request fails (e.g., a network blip), it makes sense to try again.

The Trap: The "Retry Storm"

Imagine the Inventory Service is struggling because it is overloaded.

1. Storefront calls Inventory. Fails.
2. Storefront retries immediately.
3. Storefront retries again.
4. Result: You are now DDOSing (attacking) your own service. You are kicking a man who is already down.

The Solution: Exponential Backoff

Don't retry immediately. Wait longer each time.

* Attempt 1: Fail.
* Wait 1 second. Attempt 2: Fail.
* Wait 2 seconds. Attempt 3: Fail.
* Wait 4 seconds. Attempt 4: Give up.

#### 4. Defense Line 3: The Circuit Breaker Pattern

This is the most important pattern for stability in finance. It works exactly like the electrical circuit breaker in your house.

How it works:

You wrap a "protected function call" in a Circuit Breaker object. The breaker monitors failures.

The 3 States:

1. CLOSED (Normal Operation): Traffic flows through. If calls succeed, everything is happy.
2. OPEN (The "Trip"): If the failure rate crosses a threshold (e.g., 50% failures in 10 seconds), the breaker "Trips."
   * Action: It immediately blocks _all_ calls to the failing service without even trying to connect.
   * Benefit: The failing service gets time to recover (no load). The calling service gets an instant error (no waiting).
3. HALF-OPEN (The Test): After a "sleep window" (e.g., 30 seconds), the breaker lets one request through to test the waters.
   * If it succeeds -> Reset to CLOSED.
   * If it fails -> Go back to OPEN.

#### 5. Defense Line 4: The Bulkhead Pattern

This concept comes from ship building. Ships are divided into watertight compartments (bulkheads). If the hull is breached, water fills only one compartment, and the ship stays afloat.

In Software:

You isolate resources (Thread Pools) for different dependencies.

* Without Bulkheads: One pool of 100 threads for the whole app. If "Image Service" lags, it uses all 100 threads. "Payment Service" can't get a thread.
* With Bulkheads:
  * Pool A (20 Threads): Assigned to "Image Service."
  * Pool B (20 Threads): Assigned to "Payment Service."
* Result: If Image Service lags, it consumes its 20 threads. The other 80 threads are free. The Payment Service still works perfectly.

#### 6. Comparison: Which tool when?

| **Pattern**     | **Purpose**                   | **When to use?**                                                             |
| --------------- | ----------------------------- | ---------------------------------------------------------------------------- |
| Timeout         | Don't wait forever.           | Always. Every network call needs one.                                        |
| Retry           | Handle transient glitches.    | Only for "idempotent" (safe to repeat) reads. Never retry a payment blindly! |
| Circuit Breaker | Prevent catastrophic cascade. | When a specific dependency is known to be unreliable or critical.            |
| Bulkhead        | Isolate failures.             | When you have one service calling multiple different downstream services.    |

#### 7. Quiz: Check Your Understanding

1. Scenario: The "User Profile" service is down. Your mobile app tries to load the home page. Without a Circuit Breaker, the app freezes. With a Circuit Breaker, what happens?
   * _Answer: The Circuit Breaker detects the failure and "Opens." It returns a default fallback immediately (e.g., "Guest User" or cached data). The app loads instantly, just without the profile picture._
2. Scenario: Why should you avoid "Retry" on a "Create Transaction" API?
   * _Answer: Because if the first request actually succeeded but the network timed out on the response, retrying will create a duplicate transaction. You charge the user twice._
